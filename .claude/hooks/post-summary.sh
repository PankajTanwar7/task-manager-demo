#!/bin/bash

###############################################################################
# Post Summary to GitHub
#
# Posts formatted comments to Issues (work progress) and PRs (updates)
#
# Usage (option 1 - Interactive):
#   ./.claude/hooks/post-summary.sh
#
# Usage (option 2 - With arguments):
#   ./.claude/hooks/post-summary.sh \
#     "Your prompt: Add JSDoc comments" \
#     "Achievement: Added docs to 9 files, 460+ lines, all tests passing"
#
# Format:
#   - Issue comments: "ðŸ’¬ Response #N" (work-in-progress updates)
#   - PR comments: "ðŸ”„ Update #N" (PR iteration updates)
#
# Enable/Disable:
#   - To disable: export DISABLE_AUTO_COMMENT=true
#   - To enable: unset DISABLE_AUTO_COMMENT (or export DISABLE_AUTO_COMMENT=false)
###############################################################################

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Source coverage parsing helper
source "$PROJECT_ROOT/scripts/parse-coverage.sh"

# Check if auto-commenting is disabled
if [ "$DISABLE_AUTO_COMMENT" = "true" ]; then
  echo "â„¹ï¸  Auto-commenting is disabled (DISABLE_AUTO_COMMENT=true)"
  echo "To enable: unset DISABLE_AUTO_COMMENT"
  exit 0
fi

# Get branch info
BRANCH=$(git branch --show-current 2>/dev/null || echo "")
ISSUE_NUM=$(echo "$BRANCH" | grep -oP '(?:feature|fix|issue|refactor|chore)/(\d+)' | grep -oP '\d+' || echo "")
PR_NUM=$(gh pr list --head "$BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")

if [ -z "$ISSUE_NUM" ] && [ -z "$PR_NUM" ]; then
  echo "âŒ No issue or PR found"
  exit 1
fi

# Get user input
if [ -n "$1" ]; then
  USER_PROMPT="$1"
  ACHIEVEMENT="$2"
else
  echo "What did you ask Claude to do?"
  read -r USER_PROMPT
  echo "What was achieved?"
  read -r ACHIEVEMENT
fi

# Get commits and files
BASE_BRANCH="main"
COMMITS=$(git log --oneline ${BASE_BRANCH}..HEAD 2>/dev/null | head -10)
COMMIT_COUNT=$(echo "$COMMITS" | wc -l)
CHANGED_FILES=$(git diff --name-only ${BASE_BRANCH}...HEAD 2>/dev/null)
FILE_COUNT=$(echo "$CHANGED_FILES" | grep -v '^$' | wc -l)

# Timing
FIRST_COMMIT=$(git log ${BASE_BRANCH}..HEAD --reverse --format=%ct 2>/dev/null | head -1)
LAST_COMMIT=$(git log -1 --format=%ct)
if [ -n "$FIRST_COMMIT" ]; then
  DURATION=$(( (LAST_COMMIT - FIRST_COMMIT) / 60 ))
  DURATION_STR="${DURATION}m"
else
  DURATION_STR="30m"
fi

TIMESTAMP=$(date '+%Y-%m-%d %H:%M')

# Response/Update number tracking
SESSION_FILE="$SCRIPT_DIR/../session-counter.json"
[ ! -f "$SESSION_FILE" ] && echo '{}' > "$SESSION_FILE"

# Separate counters for Issue and PR
ISSUE_KEY="issue-${ISSUE_NUM}"
PR_KEY="pr-${PR_NUM}"

# Build Issue comment (if issue exists)
if [ -n "$ISSUE_NUM" ]; then
  ISSUE_RESPONSE_NUM=$(jq -r ".[\"$ISSUE_KEY\"] // 0" "$SESSION_FILE")
  ISSUE_RESPONSE_NUM=$((ISSUE_RESPONSE_NUM + 1))
  jq ".[\"$ISSUE_KEY\"] = $ISSUE_RESPONSE_NUM" "$SESSION_FILE" > "$SESSION_FILE.tmp" && mv "$SESSION_FILE.tmp" "$SESSION_FILE"

  ISSUE_COMMENT="## ClaudeCode Response #${ISSUE_RESPONSE_NUM}

\`\`\`
Time: ${TIMESTAMP}
\`\`\`

---

### Request

\`\`\`
${USER_PROMPT}
\`\`\`

---

### Response

${ACHIEVEMENT}

---

"

  # Add coverage section if available
  COVERAGE_KEY="coverage-issue-${ISSUE_NUM}"
  COVERAGE_SECTION=$(parse_coverage_section "$SESSION_FILE" "$COVERAGE_KEY" "$ISSUE_RESPONSE_NUM")
  [ -n "$COVERAGE_SECTION" ] && ISSUE_COMMENT="${ISSUE_COMMENT}${COVERAGE_SECTION}"

  ISSUE_COMMENT="${ISSUE_COMMENT}### Files Changed

<details>
<summary>${FILE_COUNT} files modified</summary>

"

  # Add files to issue comment
  if [ $FILE_COUNT -gt 0 ]; then
    echo "$CHANGED_FILES" | head -15 | while read -r file; do
      [ -n "$file" ] && ISSUE_COMMENT="${ISSUE_COMMENT}- \`${file}\`
"
    done

    [ $FILE_COUNT -gt 15 ] && ISSUE_COMMENT="${ISSUE_COMMENT}
... and $((FILE_COUNT - 15)) more files"
  fi

  ISSUE_COMMENT="${ISSUE_COMMENT}

</details>

---

### Commits

\`\`\`
${COMMITS}
\`\`\`

---

**Status:** Implementation completed and committed locally (not pushed yet)

<sub>Response #${ISSUE_RESPONSE_NUM} - Auto-generated by ClaudeCode</sub>
"
fi

# Build PR comment (if PR exists)
if [ -n "$PR_NUM" ]; then
  PR_UPDATE_NUM=$(jq -r ".[\"$PR_KEY\"] // 0" "$SESSION_FILE")
  PR_UPDATE_NUM=$((PR_UPDATE_NUM + 1))
  jq ".[\"$PR_KEY\"] = $PR_UPDATE_NUM" "$SESSION_FILE" > "$SESSION_FILE.tmp" && mv "$SESSION_FILE.tmp" "$SESSION_FILE"

  PR_COMMENT="## ClaudeCode Update #${PR_UPDATE_NUM}

\`\`\`
Time: ${TIMESTAMP}
\`\`\`

---

### Request

\`\`\`
${USER_PROMPT}
\`\`\`

---

### Changes Made

${ACHIEVEMENT}

---

"

  # Add coverage section if available
  COVERAGE_KEY="coverage-pr-${PR_NUM}"
  COVERAGE_SECTION=$(parse_coverage_section "$SESSION_FILE" "$COVERAGE_KEY" "$PR_UPDATE_NUM")
  [ -n "$COVERAGE_SECTION" ] && PR_COMMENT="${PR_COMMENT}${COVERAGE_SECTION}"

  PR_COMMENT="${PR_COMMENT}### Files Modified

<details>
<summary>${FILE_COUNT} files changed</summary>

"

  # Add files to PR comment
  if [ $FILE_COUNT -gt 0 ]; then
    echo "$CHANGED_FILES" | head -15 | while read -r file; do
      [ -n "$file" ] && PR_COMMENT="${PR_COMMENT}- \`${file}\`
"
    done

    [ $FILE_COUNT -gt 15 ] && PR_COMMENT="${PR_COMMENT}
... and $((FILE_COUNT - 15)) more files"
  fi

  PR_COMMENT="${PR_COMMENT}

</details>

---

### New Commits

\`\`\`
${COMMITS}
\`\`\`

---

**Status:** Changes pushed to PR and ready for review

<sub>Update #${PR_UPDATE_NUM} - Auto-generated by ClaudeCode</sub>
"
fi

# Post comments
if [ -n "$ISSUE_NUM" ]; then
  echo "$ISSUE_COMMENT" | gh issue comment "$ISSUE_NUM" --body-file - && \
    echo "âœ“ Posted to Issue #${ISSUE_NUM} (Response #${ISSUE_RESPONSE_NUM})"
fi

if [ -n "$PR_NUM" ]; then
  echo "$PR_COMMENT" | gh pr comment "$PR_NUM" --body-file - && \
    echo "âœ“ Posted to PR #${PR_NUM} (Update #${PR_UPDATE_NUM})"
fi

echo "âœ… Done!"
