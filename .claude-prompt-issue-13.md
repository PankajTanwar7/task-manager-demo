[WORKFLOW-SCRIPT] Claude Code Prompt - Issue #13

## Context from GitHub Issue

**Issue:** #13 - [FEATURE] Add test coverage reporting to automation system
**Type:** feature
**Branch:** feature/13--feature-add-test-coverage-rep

---

## Acceptance Criteria
  <!-- What defines "done" for this feature? -->
  - [ ] Coverage report is generated when tests are run
  - [ ] Coverage percentage appears in post-summary.sh GitHub comments
  - [ ] Files with <80% coverage are highlighted in a list
  - [ ] Coverage section uses collapsible `<details>` tag (consistent with file lists)
  - [ ] Works for both Issue comments (Response #N) and PR comments (Update #N)
  - [ ] Gracefully handles projects without coverage configured (skips section)
  - [ ] No breaking changes to existing automation functionality
  - [ ] Coverage section appears between "Response/Changes Made" and "Files Changed"

---

## Architecture/Solution (from @claude discussion)
  <!-- Tag @claude here to discuss implementation approach -->

  @claude Please help design the architecture for this feature:

  **Questions:**
  1. Should we parse coverage from stdout or from coverage files (coverage/lcov.info)?
  2. How to detect if coverage data is available vs. not configured?
  3. Should we store/compare coverage between runs to show trends?
  4. What's the threshold for "needs attention" (currently suggesting 80%)?

  **Constraints:**
  - Tech stack: Bash scripting (post-summary.sh is bash)
  - Performance requirements: Should add <2 seconds to post-summary.sh execution
  - Security considerations: Don't expose sensitive paths or internal logic in comments
  - Compatibility: Must work with npm/jest coverage (this project uses npm test)


## @claude Recommendations
**Claude finished @PankajTanwar7's task** ‚Äî‚Äî [View job](https://github.com/PankajTanwar7/task-manager-demo/actions/runs/19561173597)

---
### Architecture Discussion for Test Coverage Reporting ‚úÖ

I've analyzed the current automation system and test infrastructure. Here are my architecture recommendations for adding test coverage reporting:

---

### Question 1: Coverage Data Source (stdout vs files)

**Recommendation: Parse from coverage files (`coverage/coverage-summary.json`)**

**Rationale:**
- **Reliability**: Jest generates `coverage-summary.json` with structured, machine-readable data
- **Performance**: Reading a JSON file is faster and more reliable than parsing stdout
- **Consistency**: File format is stable across Jest versions, stdout format may vary
- **Simplicity**: No need to handle ANSI colors, terminal formatting, or progress indicators

**Implementation Approach:**
```bash
# Check if coverage file exists
if [ -f "coverage/coverage-summary.json" ]; then
  # Parse using jq
  OVERALL_COVERAGE=$(jq -r '.total.lines.pct' coverage/coverage-summary.json)
fi
```

**Alternative considered:** Parsing `jest --coverage --json` output
- ‚ùå More complex (includes test results mixed with coverage)
- ‚ùå Slower (runs tests and coverage in one command)
- ‚ùå Harder to parse (nested JSON structure)

---

### Question 2: Coverage Availability Detection

**Recommendation: Multi-level detection approach**

**Detection Strategy:**
```bash
# Level 1: Check if coverage files exist
if [ ! -f "coverage/coverage-summary.json" ]; then
  # No coverage data available, skip section
  return
fi

# Level 2: Check if coverage file is recent (generated in current session)
FIRST_COMMIT_TIME=$(git log main..HEAD --reverse --format=%ct | head -1)
COVERAGE_FILE_TIME=$(stat -c %Y coverage/coverage-summary.json 2>/dev/null || echo 0)

if [ "$COVERAGE_FILE_TIME" -lt "$FIRST_COMMIT_TIME" ]; then
  # Coverage is stale, skip section
  return
fi

# Level 3: Validate coverage file is valid JSON
if ! jq empty coverage/coverage-summary.json 2>/dev/null; then
  # Invalid coverage file, skip section
  return
fi
```

**Graceful Handling:**
- No error messages if coverage unavailable (silent skip)
- No breaking changes to existing comments
- Works for projects without test coverage configured
- Works when user forgets to run `npm test -- --coverage`

---

### Question 3: Coverage Trend Tracking

**Recommendation: Show trends, store in session file**

**Why track trends:**
- ‚úÖ Shows progress over multiple iterations
- ‚úÖ Motivates improving coverage
- ‚úÖ Provides historical context in Issue/PR comments
- ‚úÖ Aligns with existing session counter pattern

**Storage Approach:**
Extend existing `.claude/session-counter.json`:
```json
{
  "issue-13": 2,
  "pr-15": 1,
  "coverage-issue-13": {
    "response-1": 85.2,
    "response-2": 87.5
  }
}
```

**Display Format:**
```markdown
### Test Coverage

<details>
<summary>87.5% overall coverage (+2.3% from previous)</summary>
```

**Edge Cases:**
- First response: No trend indicator
- Coverage decreased: Show with ‚ö†Ô∏è warning
- No previous data: Just show current percentage

---

### Question 4: Coverage Threshold

**Recommendation: 80% threshold, but make it configurable**

**Why 80%:**
- ‚úÖ Industry standard for good coverage
- ‚úÖ Achievable but meaningful target
- ‚úÖ Aligns with your initial suggestion
- ‚úÖ Common default in many projects

**Configuration Approach:**
```bash
# Default threshold (can be overridden)
COVERAGE_THRESHOLD=${COVERAGE_THRESHOLD:-80}

# Support for .coveragerc or config file in future
if [ -f ".coverage-threshold" ]; then
  COVERAGE_THRESHOLD=$(cat .coverage-threshold)
fi
```

**Usage in Script:**
```bash
# Files with coverage below threshold
LOW_COVERAGE=$(jq -r "
  to_entries[] 
  | select(.key != \"total\" and .value.lines.pct < $COVERAGE_THRESHOLD) 
  | .key + \" - \" + (.value.lines.pct | tostring) + \"%\"
" coverage/coverage-summary.json)
```

---

### Complete Architecture Recommendations

#### 1. **File Structure**
```
.claude/hooks/
  ‚îú‚îÄ‚îÄ post-summary.sh          # Modified (add coverage section)
  ‚îî‚îÄ‚îÄ parse-coverage.sh         # NEW (helper script - optional)

scripts/
  ‚îú‚îÄ‚îÄ start-work.sh            # No changes needed
  ‚îî‚îÄ‚îÄ cleanup-after-merge.sh   # No changes needed

docs/
  ‚îî‚îÄ‚îÄ (documentation updates)
```

#### 2. **Coverage Section Placement**

Insert between "Response/Changes Made" and "Files Changed":

```markdown
### Response
[Achievement text]

---

### Test Coverage                    ‚Üê NEW SECTION
<details>
<summary>87.5% overall coverage</summary>
...
</details>

---

### Files Changed
<details>
<summary>6 files modified</summary>
...
```

#### 3. **Performance Considerations**

**Target: <2 seconds overhead**

- ‚úÖ Reading JSON file: <10ms
- ‚úÖ Parsing with jq: <50ms  
- ‚úÖ Filtering files: <100ms
- ‚úÖ Formatting output: <50ms
- **Total: ~200ms** (well under 2s limit)

**Optimization:**
- Use `jq` for all JSON parsing (fast, reliable)
- Cache coverage file path check
- Skip section entirely if no coverage (zero overhead)

#### 4. **Security Considerations**

**Don't expose:**
- ‚ùå Absolute file paths (use relative paths only)
- ‚ùå Internal logic or algorithms
- ‚ùå Environment variables or secrets
- ‚ùå Node_modules or test framework internals

**Safe to show:**
- ‚úÖ Source file paths relative to project root (e.g., `src/auth/jwt.js`)
- ‚úÖ Coverage percentages
- ‚úÖ Test file paths
- ‚úÖ Overall statistics

**Implementation:**
```bash
# Strip leading './' or absolute paths
FILE_PATH=$(echo "$file" | sed 's|^\./||' | sed 's|^/.*task-manager-demo/||')
```

---

### Implementation Plan

#### Phase 1: Core Functionality (Minimum Viable)
1. Detect coverage file existence
2. Parse overall coverage percentage
3. Display in collapsible `<details>` section
4. Gracefully skip if no coverage available

#### Phase 2: File-Level Details
5. List files below threshold (<80%)
6. List well-covered files (‚â•80%)
7. Show per-file percentages
8. Limit file list to prevent huge comments (e.g., top 15)

#### Phase 3: Trends & Polish
9. Store coverage in session-counter.json
10. Show trend indicators (+/-%)
11. Handle edge cases (first run, no previous data)
12. Update documentation

---

### Affected Files (Final List)

#### Must Modify:
- `.claude/hooks/post-summary.sh` - Add coverage section logic
  - Insert function to parse coverage
  - Add coverage section to both Issue and PR comment formats
  - Handle graceful skipping

#### Optional (Recommended):
- `scripts/parse-coverage.sh` (NEW) - Separate helper for coverage parsing
  - Makes post-summary.sh cleaner
  - Easier to test independently
  - Reusable for other scripts

#### Documentation Updates:
- `COMPLETE-VISUAL-WORKFLOW.md` - Add coverage section to comment examples
- `AUTOMATION-FAQ.md` - Add Q&A about coverage reporting
  - Q: "How do I enable coverage reporting?"
  - Q: "Why isn't coverage showing up?"
  - Q: "How do I change the coverage threshold?"

---

### Example Output Format

#### Issue Comment (Response #N):
```markdown
## ClaudeCode Response #3

### Request
`Add user authentication endpoints`

---

### Response

Implemented JWT-based authentication with login/register endpoints,
bcrypt password hashing, and middleware. All tests passing.

---

### Test Coverage

<details>
<summary>87.5% overall coverage (+2.3% from previous)</summary>

**Files needing attention (<80%):**
- `src/middleware/auth.js` - 72.5% coverage
- `src/utils/validation.js` - 65.3% coverage

**Well covered (‚â•80%):**
- `src/auth/jwt.js` - 95.0% coverage
- `src/routes/auth.js` - 88.7% coverage
- `tests/auth.test.js` - 100% coverage

**Overall Statistics:**
- Lines: 87.5% (210/240)
- Statements: 86.8% (220/253)
- Functions: 90.0% (18/20)
- Branches: 82.5% (33/40)

</details>

---

### Files Changed
...
```

---

### Key Design Decisions Summary

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **Data Source** | `coverage-summary.json` | Structured, reliable, fast |
| **Detection** | Multi-level checks | Graceful handling, no false positives |
| **Trends** | Store in session file | Historical context, motivation |
| **Threshold** | 80% (configurable) | Industry standard, achievable |
| **Performance** | <200ms overhead | Well under 2s requirement |
| **Security** | Relative paths only | No sensitive data exposure |
| **Format** | Collapsible `<details>` | Consistent with existing UI |
| **Placement** | After Response, before Files | Logical flow, prominent |

---

### Next Steps (Phase 2: Implementation)

Ready to proceed with implementation in Claude Code:

1. **Create branch**: `feature/13-add-coverage-reporting`
2. **Implement coverage parsing in post-summary.sh**
3. **Add graceful handling for missing coverage**
4. **Test with coverage enabled and disabled**
5. **Update documentation files**
6. **Create PR with reference to this issue**

**Estimated Implementation Time:** 1-2 hours
**Testing Scenarios:**
- ‚úÖ Project with coverage configured (this repo)
- ‚úÖ Coverage file exists and is recent
- ‚úÖ Coverage file missing (graceful skip)
- ‚úÖ Multiple iterations (trend tracking)
- ‚úÖ Both Issue and PR comments

---

### Questions or Concerns?

Please review the architecture recommendations above. If you approve, I can proceed with Phase 2 (Implementation) using Claude Code.

**Approval needed for:**
- ‚úÖ Coverage data source (JSON file)
- ‚úÖ 80% threshold (with configurability)
- ‚úÖ Trend tracking approach
- ‚úÖ File list in coverage section

Once approved, I'll generate the Claude Code prompt for implementation.

---
**Claude finished @PankajTanwar7's task** ‚Äî‚Äî [View job](https://github.com/PankajTanwar7/task-manager-demo/actions/runs/19561564812)

---
### Claude Code Implementation Prompt Generated ‚úÖ

**Tasks:**
- [x] Review approved architecture decisions
- [x] Generate comprehensive Claude Code prompt
- [x] Include all implementation requirements
- [x] Format for easy copying

---

## üöÄ Claude Code Implementation Prompt

Copy and use this prompt when working with Claude Code to implement the test coverage reporting feature:

---

### Prompt for Claude Code:

```
Implement the test coverage reporting feature for GitHub automation system from Issue #13.

CONTEXT FROM ARCHITECTURE DISCUSSION:

Approved Architecture Decisions:
1. Data Source: Parse coverage from coverage-summary.json (not stdout)
   - More reliable, structured JSON format
   - Faster performance (~200ms overhead target)
   
2. Coverage Detection: Multi-level approach
   - Check if coverage-summary.json exists
   - Verify file is recent (not stale)
   - Validate JSON format
   - Gracefully skip section if unavailable (no errors)

3. Trend Tracking: Store coverage history in session file
   - Extend existing .claude/session-counter.json
   - Add coverage-{type}-{number} entries
   - Show trend indicators (+/- from previous)
   
4. Coverage Threshold: 80% (configurable)
   - Use COVERAGE_THRESHOLD environment variable (default 80)
   - Support future .coverage-threshold file
   - List files below threshold as "needing attention"

5. Performance: Must add <2 seconds to post-summary.sh execution
   - Use jq for JSON parsing (fast, reliable)
   - Cache file path checks
   - Current estimate: ~200ms overhead

6. Security: Only show relative paths
   - Strip absolute paths and ./ prefixes
   - Don't expose environment variables or internals
   - Only show source files relative to project root

IMPLEMENTATION REQUIREMENTS:

Files to Modify:
1. .claude/hooks/post-summary.sh (PRIMARY)
   - Add parse_coverage() function
   - Insert coverage section in both Issue and PR comment formats
   - Place coverage section AFTER "Response/Changes Made" and BEFORE "Files Changed"
   - Handle graceful skipping when coverage unavailable

2. scripts/parse-coverage.sh (OPTIONAL - if it simplifies post-summary.sh)
   - Separate helper script for coverage parsing
   - Makes post-summary.sh cleaner and more maintainable
   - Easier to test independently

3. Documentation Updates:
   - COMPLETE-VISUAL-WORKFLOW.md - Add coverage section to comment examples
   - AUTOMATION-FAQ.md - Add Q&A section about coverage reporting
     * Q: "How do I enable coverage reporting?"
     * Q: "Why isn't coverage showing up?"
     * Q: "How do I change the coverage threshold?"

Coverage Section Format:
```markdown
### Test Coverage

<details>
<summary>87.5% overall coverage (+2.3% from previous)</summary>

**Files needing attention (<80%):**
- `src/middleware/auth.js` - 72.5% coverage
- `src/utils/validation.js` - 65.3% coverage

**Well covered (‚â•80%):**
- `src/auth/jwt.js` - 95.0% coverage
- `src/routes/auth.js` - 88.7% coverage
- `tests/auth.test.js` - 100% coverage

**Overall Statistics:**
- Lines: 87.5% (210/240)
- Statements: 86.8% (220/253)
- Functions: 90.0% (18/20)
- Branches: 82.5% (33/40)

</details>
```

Placement in Comments:
```markdown
### Response
[Achievement text]

---

### Test Coverage          ‚Üê INSERT HERE
<details>...</details>

---

### Files Changed
<details>...</details>
```

Technical Implementation Details:

1. Coverage Detection Logic:
```bash
parse_coverage() {
  # Check if coverage file exists
  if [ ! -f "coverage/coverage-summary.json" ]; then
    return 0  # Skip silently
  fi
  
  # Validate JSON
  if ! jq empty coverage/coverage-summary.json 2>/dev/null; then
    return 0  # Skip if invalid
  fi
  
  # Parse overall coverage
  OVERALL_COVERAGE=$(jq -r '.total.lines.pct' coverage/coverage-summary.json)
  
  # Get previous coverage from session file (if exists)
  # Show trend indicator if available
  
  # Parse files below threshold
  # Parse files above threshold
  # Limit lists to top 10-15 to prevent huge comments
}
```

2. Session Storage Pattern:
```bash
# Store coverage in session-counter.json
SESSION_TYPE="issue"  # or "pr"
SESSION_NUM=$(get_current_session_number)
COVERAGE_KEY="coverage-${SESSION_TYPE}-${ISSUE_OR_PR_NUMBER}"

# Update session file with current coverage
jq --arg key "$COVERAGE_KEY" \
   --arg session "$SESSION_TYPE-$SESSION_NUM" \
   --argjson coverage "$OVERALL_COVERAGE" \
   '.[$key][$session] = $coverage' \
   .claude/session-counter.json > tmp && mv tmp .claude/session-counter.json
```

3. Trend Calculation:
```bash
# Get previous coverage
PREV_COVERAGE=$(jq -r ".[\"$COVERAGE_KEY\"][\"$SESSION_TYPE-$((SESSION_NUM-1))\"] // null" \
                .claude/session-counter.json)

if [ "$PREV_COVERAGE" != "null" ]; then
  TREND=$(echo "$OVERALL_COVERAGE - $PREV_COVERAGE" | bc)
  if [ $(echo "$TREND > 0" | bc) -eq 1 ]; then
    TREND_INDICATOR="(+${TREND}% from previous)"
  elif [ $(echo "$TREND < 0" | bc) -eq 1 ]; then
    TREND_INDICATOR="(${TREND}% from previous)"
  fi
fi
```

ACCEPTANCE CRITERIA (must all be met):

- [ ] Coverage report section appears in both Issue comments (Response #N) and PR comments (Update #N)
- [ ] Overall coverage percentage is displayed in summary line
- [ ] Files with <80% coverage are listed under "Files needing attention"
- [ ] Files with ‚â•80% coverage are listed under "Well covered"
- [ ] Section uses collapsible `<details>` tag (consistent with existing sections)
- [ ] Trend indicators show when previous coverage data exists
- [ ] Gracefully handles projects without coverage (silent skip, no errors)
- [ ] No breaking changes to existing automation functionality
- [ ] Coverage section appears between "Response/Changes Made" and "Files Changed"
- [ ] Performance overhead is <2 seconds (should be ~200ms)
- [ ] Security: Only relative file paths shown (no absolute paths or sensitive data)
- [ ] Documentation updated with examples and FAQ

TESTING REQUIREMENTS:

Test Scenarios:
1. ‚úÖ Normal case: Coverage file exists and is valid
   - Run: npm test -- --coverage
   - Verify coverage section appears with correct data
   
2. ‚úÖ Missing coverage: No coverage file present
   - Don't run coverage
   - Verify section is silently skipped (no errors in output)
   
3. ‚úÖ Stale coverage: Old coverage file from previous session
   - Use old coverage file
   - Verify it's detected as stale and skipped
   
4. ‚úÖ First run: No previous coverage data
   - Verify no trend indicator shown
   - Verify baseline coverage stored
   
5. ‚úÖ Multiple iterations: Test trend tracking
   - Run coverage multiple times with different results
   - Verify trend indicators (+/- %) appear correctly
   
6. ‚úÖ Both Issue and PR comments
   - Test on Issue (Response #N format)
   - Test on PR (Update #N format)
   - Verify consistent formatting

Testing Commands:
```bash
# Test with coverage
npm test -- --coverage
.claude/hooks/post-summary.sh

# Test without coverage
rm -rf coverage/
.claude/hooks/post-summary.sh

# Check session file updates
cat .claude/session-counter.json | jq .
```

COMMIT REQUIREMENTS:

Use conventional commit format with proper co-authorship:

```bash
git add .claude/hooks/post-summary.sh scripts/parse-coverage.sh docs/
git commit -m "feat: add test coverage reporting to automation system

- Add coverage parsing from coverage-summary.json
- Display overall coverage with trend indicators
- List files above/below 80% threshold
- Gracefully handle missing coverage data
- Update documentation with examples and FAQ

Implements #13

Co-authored-by: PankajTanwar7 <PankajTanwar7@users.noreply.github.com>"

git push origin feature/13-add-coverage-reporting
```

IMPORTANT NOTES:

1. Use existing patterns from post-summary.sh:
   - Follow the same formatting style
   - Use existing helper functions where applicable
   - Maintain consistency with "Files Changed" section
   
2. Handle edge cases gracefully:
   - Invalid JSON format
   - Missing fields in coverage file
   - Corrupted coverage data
   - Division by zero scenarios
   
3. Performance considerations:
   - Minimize jq calls (combine queries where possible)
   - Cache repeated calculations
   - Limit file lists to prevent huge comments (max 15 files per category)
   
4. Security best practices:
   - Always strip absolute paths
   - Never expose environment variables
   - Validate all inputs before processing
   - Use proper shell quoting

Please implement this feature with all tests passing and proper documentation updates. Commit with the message format above when complete.
```

---

### Next Steps

1. **Copy the prompt above** into your Claude Code desktop application
2. **Create the feature branch**: `feature/13-add-coverage-reporting`
3. **Let Claude Code implement** the feature with all requirements
4. **Test locally** using the testing scenarios provided
5. **Create a PR** when implementation is complete
6. **Verify coverage section** appears correctly in the PR comment

The prompt includes all approved architecture decisions, implementation details, acceptance criteria, and testing requirements. Claude Code will have everything needed to implement this feature correctly.

---


---

## Files to Modify
  <!-- List files that will likely need changes -->
  - `.claude/hooks/post-summary.sh` - Main script to add coverage parsing and formatting
  - `scripts/parse-coverage.sh` (NEW) - Helper script to extract coverage data (optional)
  - `COMPLETE-VISUAL-WORKFLOW.md` - Update to show coverage section in comment examples
  - `AUTOMATION-FAQ.md` - Add Q&A about coverage reporting

---

## Your Task

Please implement this feature according to the specifications above.

**Requirements:**
1. Follow the architecture discussed in the issue
2. Implement all acceptance criteria
3. Write/update tests
4. Ensure existing tests pass
5. Commit with proper message: "feature: <description> (#13)"

**Note:** This session will be auto-logged to docs/dev-logs/issue-13.md
